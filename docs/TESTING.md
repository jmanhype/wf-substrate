# Testing Guide

## Test Organization

### New Test Modules

- **wf_test_term.erl**: Bytecode structure validation (placeholder for AST tests)
- **wf_test_seq.erl**: Sequential composition tests
- **wf_test_par.erl**: Parallel split and synchronization tests
- **wf_test_xor.erl**: Exclusive choice and simple merge tests
- **wf_test_join.erl**: All join policy tests
- **wf_test_cancel.erl**: Activity/case/region cancellation tests
- **wf_test_mi.erl**: Multiple instance pattern tests

### Test Helper Modules

- **wf_test_helpers.erl**: Common test utilities
- **wf_prop.erl**: Minimal property-based testing framework

### Existing Test Modules

- **wf_exec_tests.erl**: Executor implementation tests
- **wf_sched_tests.erl**: Scheduler policy tests
- **wf_validate_tests.erl**: Validation engine tests
- **wf_state_tests.erl**: State management tests
- **wf_mi_tests.erl**: Multiple instance semantics tests
- **wf_trace_tests.erl**: Trace and replay tests
- **wf_substrate_tests.erl**: Test suite entry point

## Running Tests

### Run All Tests

```bash
rebar3 eunit
```

### Run Specific Test Module

```bash
rebar3 eunit --module=wf_test_seq
rebar3 eunit --module=wf_test_par
rebar3 eunit --module=wf_test_xor
rebar3 eunit --module=wf_test_join
rebar3 eunit --module=wf_test_cancel
rebar3 eunit --module=wf_test_mi
rebar3 eunit --module=wf_test_term
```

### Run Specific Test Function

```bash
rebar3 eunit --test=wf_test_seq:seq_2_tasks_executed_in_order_test
```

### Generate Coverage Report

```bash
rebar3 cover
```

Coverage report generated in `_build/test/cover/index.html`

## Coverage Goals

- **Line coverage**: > 80% for all core modules
- **Pattern coverage**: All 43 workflow patterns tested
- **Edge case coverage**: Test boundary conditions (0, 1, large N)

## Test Patterns

### Mock Bytecode Generators

Each test module defines mock bytecode generators for pattern variations:

```erlang
%% Example from wf_test_seq.erl
mock_bytecode_seq_2_tasks() ->
    [
        {'SEQ_ENTER', 0},
        {'TASK_EXEC', task_a},
        {'SEQ_NEXT', 3},
        {'TASK_EXEC', task_b},
        {'DONE'}
    ].
```

### Setup/Teardown Pattern

For gen_server tests (like wf_state_tests.erl):

```erlang
setup() ->
    {ok, Pid} = wf_state:start_link(),
    Pid.

cleanup(Pid) ->
    gen_server:stop(Pid).

my_test_() ->
    {setup, fun setup/0, fun cleanup/1, [
        ?_test(assert_something())
    ]}.
```

### Parameterized Tests

Generate tests for multiple input values:

```erlang
%% From wf_test_par.erl
par_n_branches_test_() ->
    lists:map(fun(M) ->
        {io_lib:format("par_~p_branches", [M]), fun() ->
            Bytecode = mock_bytecode_par_n_branches(M),
            ExecState0 = wf_exec:new(Bytecode),
            {done, ExecState1} = wf_exec:run(ExecState0, 1000, undefined),
            ?assert(wf_exec:is_done(ExecState1))
        end}
    end, [2, 3, 5, 10]).
```

## Property-Based Testing

### Running Property Tests

Property tests use custom framework (wf_prop.erl) with random bytecode generation:

```erlang
%% From wf_test_term.erl
prop_random_bytecode_executable_test() ->
    Property = fun(Bytecode) ->
        ExecState = wf_exec:new(Bytecode),
        ?assert(is_record(ExecState, exec_state))
    end,
    wf_prop:for_all(fun() -> wf_prop:random_term(5) end, Property, 50).
```

### Random Bytecode Generation

The `wf_prop:random_term/1` function generates random bytecode with depth limit:

- **Depth 0**: Simple DONE-only bytecode
- **Depth 1-3**: Simple task sequences (1-3 tasks)
- **Depth 4-6**: Parallel patterns (2-4 branches)
- **Depth 7-8**: XOR patterns (2-4 branches)
- **Depth 9-10**: Sequences with cancellation

### Property Examples

1. **Opcode Format**: All generated opcodes are valid tuples
2. **Executable**: All generated bytecode can be executed without crashing
3. **Termination**: All generated bytecode terminates within bounded steps
4. **Label Resolution**: All jump targets are within bytecode bounds

### Reproducing Failing Property Tests

Failing property tests in `wf_prop:quickcheck/2` return:
```
{error, Bytecode, Exception}
```

To reproduce:
1. Extract the failing bytecode from the error tuple
2. Create a test case with that specific bytecode
3. Debug the failure

For `wf_prop:for_all/3`, failures are reported as EUnit assertions.

## Test Execution Time

Target test execution times:
- Unit tests: < 10 seconds
- Property tests: < 20 seconds (100 iterations)
- Full test suite: < 30 seconds

## Continuous Integration

CI runs:
```bash
rebar3 compile
rebar3 eunit
rebar3 cover
```

Tests must pass before merging PR.

## Test Module Details

### wf_test_mi.erl - Multiple Instance Patterns

Tests:
- Fixed count MI (3, 5 instances)
- Dynamic count MI (min/max bounds)
- Join policies: wait_all, wait_n, first_complete, none
- Cancellation of remaining instances
- Instance ID uniqueness and sequential numbering

### wf_test_seq.erl - Sequential Composition

Tests:
- Single sequences (2, 3, N tasks)
- Nested sequences
- Sequences with effects
- Sequences with cancellation mid-way
- Empty sequences
- SEQ_NEXT jump target correctness

### wf_test_par.erl - Parallel Split and Synchronization

Tests:
- 2-branch parallel
- 3-branch parallel
- N-branch parallel (2, 3, 5, 10)
- Mixed completion times
- Join policies: wait_all, wait_n, first_complete
- Join counter creation and increments

### wf_test_xor.erl - Exclusive Choice

Tests:
- 2-branch XOR
- 3-branch XOR
- N-branch XOR (2, 3, 5)
- Simple merge convergence
- Deterministic scheduler selection
- Unselected branches don't execute

### wf_test_join.erl - All Join Policies

Tests:
- wait_all (M = 2, 3, 5, 10)
- wait_n (various N of M combinations)
- first_complete (discriminator)
- sync_merge
- Join counter mechanics
- Edge cases: N=0, N=M, N=1

### wf_test_cancel.erl - Cancellation Patterns

Tests:
- Cancel running task
- Cancel case with active PAR branches
- Cancel case with XOR
- Cancel during MI
- Nested cancel scopes
- Empty cancel scope
- Scope stack management

### wf_test_term.erl - Bytecode Structure

Tests:
- Opcode format validation
- Label resolution (PAR_FORK, XOR_CHOOSE)
- Balanced scopes
- Property tests for random bytecode
- Bounded termination

## Helper Functions (wf_test_helpers.erl)

- `exec_until_done/1`: Execute workflow until completion
- `exec_steps/2`: Execute N steps manually
- `get_token_statuses/1`: Extract all token statuses
- `count_tokens_with_status/2`: Count tokens by status
- `assert_join_counter/2`: Assert join counter state
