{
  "schema_version": 1,
  "id": "011-tracing-and-replay",
  "title": "Implement structured tracing and replay system",
  "state": "done",
  "overview": "Implement wf_trace.erl: structured trace events for every reduction step in the executor. Each trace event contains: step_seq (monotonic sequence number), opcode (the instruction executed), state_before (snapshot or diff of exec_state before), state_after (snapshot or diff after), timestamp (monotonic microseconds), scope (current cancel scope stack), branch_id (if in a parallel branch), additional metadata per opcode type.\n\nTrace levels:\n- none: no tracing overhead, trace callbacks are no-ops.\n- min: emit only structural events (fork, join, cancel, effect_yield, done) \u2014 low overhead for production.\n- full: emit every single reduction step \u2014 for debugging and replay validation.\n\nReplay log format: a list of {step_seq, opcode, scheduler_choice, effect_result} tuples sufficient to deterministically reproduce an execution. The replay log is a subset of the full trace \u2014 it captures only the nondeterministic inputs (scheduler choices and effect results), not the derived state.\n\nIntegration: wf_exec calls wf_trace:emit/2 after each step. Trace sink is configurable (function callback, ETS table, or process). Trace events are structured terms, not formatted strings.\n\nExport: new/1 (trace level), emit/2, set_sink/2, get_events/1, to_replay_log/1, from_replay_log/1, filter/2 (filter events by opcode/scope/branch).",
  "branch": null,
  "pr_url": null,
  "pr_number": null,
  "last_error": null,
  "created_at": "2026-02-10T00:00:00.000Z",
  "updated_at": "2026-02-10T00:00:00.000Z"
}