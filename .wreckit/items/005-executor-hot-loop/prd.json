{
  "schema_version": 1,
  "id": "005-executor-hot-loop",
  "branch_name": "wreckit/005-executor-hot-loop",
  "user_stories": [
    {
      "id": "US-001",
      "title": "Define exec_state record and helper records",
      "acceptance_criteria": [
        "exec_state record defined with all required fields: ip, bytecode, ctx, tokens, branch_map, join_counters, scope_stack, step_count, status, current_token",
        "token record defined with fields: token_id, ip, scope_id, value, status",
        "branch_info record defined with fields: branch_id, tokens, join_id, targets",
        "join_counter record defined with fields: join_id, completed, required, policy, results",
        "All records have -type declarations in wf_vm.erl or wf_exec.erl",
        "new/1 function creates initial exec_state from bytecode",
        "fetch_opcode/1 function returns opcode at current IP",
        "get_ip/1, get_ctx/1, get_step_count/1 query functions work correctly",
        "Mock bytecode generator creates valid test bytecode",
        "rebar3 compile succeeds with no warnings",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 1,
      "status": "done",
      "notes": "This is the foundation for all executor functionality. Must be completed before any opcode handlers can be implemented."
    },
    {
      "id": "US-002",
      "title": "Implement single-token executor (TASK_EXEC, SEQ_ENTER, SEQ_NEXT, DONE)",
      "acceptance_criteria": [
        "execute_opcode/2 dispatches to opcode handlers via pattern matching",
        "execute_seq_enter/2 pushes new scope onto scope_stack, advances IP",
        "execute_seq_next/2 jumps to target IP (right branch)",
        "execute_task_exec/2 executes mock task, updates context, advances IP",
        "execute_done/1 marks token complete, sets executor status to done if all tokens complete",
        "step/2 executes single reduction and returns updated state + trace event",
        "run/3 executes up to Quanta reductions, returns {yield, State} or {done, State}",
        "is_done/1 returns true for status=done/cancelled/failed",
        "is_blocked/1 returns false for single-token executor (no blocking yet)",
        "Single task execution: TASK_EXEC → DONE → status=done",
        "Sequence execution: TASK_EXEC → SEQ_NEXT → TASK_EXEC → DONE → status=done",
        "Quanta execution with Quanta=1 yields after every step",
        "run/3 with Quanta=100 completes entire workflow and returns {done, State}",
        "All tests pass: single_task_test_, done_test_, sequence_test_, quanta_yield_test_, run_until_done_test_",
        "rebar3 eunit passes all single-token executor tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 1,
      "status": "done",
      "notes": "Single-token executor is the minimal viable executor. No parallelism, no blocking, no cancellation. Focus on IP advancement and exec_state updates."
    },
    {
      "id": "US-003",
      "title": "Implement multi-token executor (PAR_FORK, JOIN_WAIT, XOR_CHOOSE)",
      "acceptance_criteria": [
        "execute_par_fork/2 spawns N tokens with independent IPs",
        "PAR_FORK creates branch_info record and stores in branch_map",
        "PAR_FORK creates join_counter record and stores in join_counters",
        "PAR_FORK removes current token, adds N branch tokens to tokens map",
        "execute_join_wait/2 checks join counter (completed >= required)",
        "JOIN_WAIT merges results and continues when join satisfied",
        "JOIN_WAIT sets status=blocked_join when join not satisfied",
        "execute_xor_choose/3 selects ONE branch via scheduler decision",
        "XOR_CHOOSE updates current token's IP to selected branch",
        "XOR_CHOOSE does NOT spawn multiple tokens (only one token exists)",
        "DONE handler updated for multi-token context (selects next token when others active)",
        "select_next_token/1 selects next active token (deterministic: first active token)",
        "remove_branch_by_join/2 removes branch entry when join satisfied",
        "merge_results/2 merges branch results per join policy",
        "Test: PAR_FORK with 2 branches spawns 2 tokens",
        "Test: JOIN_WAIT blocks until both branches complete",
        "Test: XOR_CHOOSE selects one branch (only 1 token)",
        "Test: Parallel execution terminates after both branches complete and join satisfied",
        "Token count invariant preserved (never negative, never exceeds reasonable bound)",
        "All tests pass: par_fork_test_, join_wait_test_, xor_choose_test_",
        "rebar3 eunit passes all multi-token executor tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 1,
      "status": "done",
      "notes": "Multi-token executor adds parallelism. PAR_FORK spawns N tokens. JOIN_WAIT synchronizes. XOR_CHOOSE selects one branch. DONE handler updated for multi-token context."
    },
    {
      "id": "US-004",
      "title": "Implement loop support (LOOP_CHECK, LOOP_BACK)",
      "acceptance_criteria": [
        "execute_loop_check/2 evaluates loop condition (exit or continue)",
        "execute_loop_back/2 jumps to loop head (target IP)",
        "evaluate_loop_condition/2 supports three loop policies: {count, N}, while, until",
        "Count loop: decrement counter stored in context, exit when counter = 0",
        "While loop: check condition first, exit if false",
        "Until loop: check condition after body, exit if true",
        "Test: Count loop with N=3 executes loop body exactly 3 times",
        "Test: LOOP_BACK jumps to LOOP_CHECK (IP set to target)",
        "Test: Loop exits when condition false (continues to exit label)",
        "Test: Nested loops work correctly (loop within loop)",
        "All tests pass: loop_count_test_",
        "rebar3 eunit passes all loop executor tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 2,
      "status": "pending",
      "notes": "Loop support adds structured cycles. LOOP_CHECK evaluates condition. LOOP_BACK jumps to loop head. Three loop policies supported: count, while, until."
    },
    {
      "id": "US-005",
      "title": "Implement cancellation support (CANCEL_SCOPE)",
      "acceptance_criteria": [
        "execute_cancel_scope/2 handles {enter, ScopeId} and {exit, ScopeId} opcodes",
        "CANCEL_SCOPE enter pushes scope onto scope_stack",
        "CANCEL_SCOPE exit pops scope from scope_stack",
        "CANCEL_SCOPE exit checks if scope is cancelled (calls wf_cancel:is_cancelled/2 stub)",
        "CANCEL_SCOPE exit propagates cancellation to all tokens in scope (calls wf_cancel:propagate/2 stub)",
        "Stub functions: is_scope_cancelled/2 (always returns false for now)",
        "Stub functions: propagate_cancellation/2 (marks all tokens in scope as cancelled)",
        "Test: CANCEL_SCOPE enter pushes scope onto stack (length = 2)",
        "Test: CANCEL_SCOPE exit pops scope from stack (length = 1)",
        "Test: Nested cancel scopes work correctly (enter s1, enter s2, exit s2, exit s1)",
        "Test: Scope stack always contains at least root (never empty)",
        "Test: Cancellation propagation marks all tokens in scope as cancelled",
        "All tests pass: cancel_scope_test_",
        "rebar3 eunit passes all cancellation executor tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 2,
      "status": "pending",
      "notes": "Cancellation support adds scope management. CANCEL_SCOPE enter/exit opcodes push/pop scope_stack. Stub wf_cancel integration (real implementation in item 008)."
    },
    {
      "id": "US-006",
      "title": "Implement effect yield support (TASK_EXEC effect)",
      "acceptance_criteria": [
        "execute_task_exec/2 detects {effect, EffectSpec, ContCtx} return from task",
        "Effect yield sets status=blocked_effect",
        "Effect yield stores continuation context in exec_state.ctx",
        "Effect yield does NOT advance IP (resumes at same opcode)",
        "Task execution error ({error, Reason}) sets status=failed",
        "resume/2 function continues execution after effect result",
        "resume/2 updates context with effect result",
        "resume/2 clears blocked status, advances IP",
        "run/3 detects status=blocked_effect and returns {effect, EffectSpec, ExecState}",
        "lookup_task_function/2 looks up task function from bytecode metadata (mock for now)",
        "Test: Task returning {effect, Spec, ContCtx} sets status=blocked_effect",
        "Test: is_blocked/1 returns true when status=blocked_effect",
        "Test: resume/2 with effect result sets status=running and advances IP",
        "Test: Task returning {error, Reason} sets status=failed",
        "Test: Effect round-trip (yield → resume → continue)",
        "All tests pass: effect_yield_test_",
        "rebar3 eunit passes all effect yield tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 2,
      "status": "pending",
      "notes": "Effect yield support allows tasks to request external operations (HTTP calls, file I/O, etc.). Executor yields to wf_effect manager (item 010). Stub for now."
    },
    {
      "id": "US-007",
      "title": "Integrate with scheduler (wf_sched)",
      "acceptance_criteria": [
        "run/3 calls wf_sched:select_action/2 to get scheduler decision",
        "step/2 passes scheduler decision to execute_opcode/3",
        "execute_opcode/3 passes scheduler decision to XOR_CHOOSE handler",
        "execute_xor_choose/3 uses scheduler decision to select branch",
        "wf_sched stub module created with select_action/2 function",
        "wf_sched supports three policies: deterministic, nondeterministic, replay",
        "Deterministic scheduler: select first active token (stable ordering)",
        "Nondeterministic scheduler: random selection with logging (mock)",
        "Replay scheduler: use logged choices (mock)",
        "Test: Run with deterministic scheduler produces reproducible trace",
        "Test: XOR_CHOOSE with scheduler decision selects correct branch",
        "Test: Scheduler selects token from tokens map",
        "All tests pass: scheduler_integration_test_",
        "rebar3 eunit passes all scheduler integration tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 2,
      "status": "pending",
      "notes": "Scheduler integration enables deterministic and nondeterministic execution. wf_sched module (item 007) provides policies. Stub implementation for now."
    },
    {
      "id": "US-008",
      "title": "Integrate with tracing (wf_trace)",
      "acceptance_criteria": [
        "step/2 calls wf_trace:emit_before/2 before opcode execution",
        "step/2 calls wf_trace:emit_after/3 after opcode execution",
        "wf_trace stub module created with emit_before/2, emit_after/3, emit_if/2 functions",
        "wf_trace supports trace levels: none, min, full",
        "wf_trace:set_level/1 sets trace level",
        "wf_trace:get_level/0 gets current trace level",
        "Trace event contains: type (before/after), opcode, IP, step_count, timestamp",
        "Trace level none: no trace events emitted",
        "Trace level min: basic events emitted",
        "Trace level full: detailed events emitted",
        "Test: Trace event emitted for every reduction when trace_level=full",
        "Test: No trace events emitted when trace_level=none",
        "Test: Trace event contains correct fields (opcode, IP, timestamp)",
        "Test: Tracing overhead is acceptable (measure steps/sec)",
        "All tests pass: tracing_test_",
        "rebar3 eunit passes all tracing integration tests",
        "rebar3 dialyzer passes with no type errors"
      ],
      "priority": 3,
      "status": "pending",
      "notes": "Tracing integration enables observability and replay. wf_trace module (item 011) emits trace events. Stub implementation for now."
    },
    {
      "id": "US-009",
      "title": "Write comprehensive tests",
      "acceptance_criteria": [
        "All opcode handler tests pass (SEQ_ENTER, SEQ_NEXT, PAR_FORK, JOIN_WAIT, XOR_CHOOSE, LOOP_CHECK, LOOP_BACK, CANCEL_SCOPE, TASK_EXEC, DONE)",
        "All termination detection tests pass (is_done/1 returns true for done/cancelled/failed)",
        "All blocking detection tests pass (is_blocked/1 returns true for blocked_effect/blocked_join/blocked_signal)",
        "All cooperative scheduling tests pass (quanta=1 yields after 1 step, quanta=10 yields after 10 steps)",
        "All state invariant tests pass (token count non-negative, IP in bounds, step count increases, scope stack well-formed)",
        "All edge case tests pass (empty bytecode, single DONE, nested par, deep loop nesting, multiple cancel scopes)",
        "Property-based tests pass (token count invariant, IP bounds invariant, step count invariant, scope stack invariant)",
        "Code coverage > 90% for wf_exec.erl module",
        "rebar3 eunit passes all comprehensive tests",
        "rebar3 proper passes all property-based tests (if proper is available)",
        "rebar3 dialyzer passes with no type errors",
        "Manual testing steps completed (inspect trace logs, profile performance, test under load)"
      ],
      "priority": 2,
      "status": "pending",
      "notes": "Comprehensive testing validates all executor functionality. Unit tests for each opcode handler. Integration tests for complete workflows. Property-based tests for invariants. Edge case tests for corner cases."
    }
  ]
}
