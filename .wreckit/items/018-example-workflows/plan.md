# Implement example workflow modules Implementation Plan

## Implementation Plan Title

Example Workflow Modules: Educational Demonstrations of Workflow Patterns

## Overview

Create four example workflow modules (wf_example_*.erl) that demonstrate real-world workflow patterns using the wf_substrate bytecode executor. Each example module will be self-contained with three exports (term/0, run/0, expected_trace_structure/0) and will include detailed comments explaining the pattern being demonstrated. A test module (wf_test_examples.erl) will validate that each example's actual execution trace matches its expected structure.

These examples serve as educational resources for users learning to compose workflows from bytecodes, showing realistic scenarios (vending machine, approval workflow, cancel region, multiple instances) rather than abstract unit tests.

## Current State

**Existing Infrastructure:**
- Executor (wf_exec.erl) handles opcodes: SEQ_ENTER, SEQ_NEXT, PAR_FORK, JOIN_WAIT, XOR_CHOOSE, LOOP_CHECK, LOOP_BACK, CANCEL_SCOPE, TASK_EXEC, DONE (lines 187-208)
- Bytecode type definitions (wf_vm.erl) define all opcode formats (lines 9-21)
- Tracing infrastructure (wf_trace.erl) supports none/min/full trace levels with ETS sink (lines 80-142)
- Test modules (wf_test_seq, wf_test_par, wf_test_xor, wf_test_join, wf_test_cancel) show bytecode patterns but are unit tests, not narrative examples
- Helper module (wf_test_trace_helpers.erl:63-98) demonstrates run_with_trace/3 pattern

**Known Limitations:**
1. **MI_SPAWN not implemented**: Opcode referenced in wf_test_mi.erl:20 but has no handler in wf_exec:execute_opcode/2 (item 009 incomplete)
2. **Cancellation stubbed**: wf_exec.erl:512-529 returns false/noop, awaiting item 008
3. **No scheduler module**: wf_sched doesn't exist, scheduler policy parameter ignored
4. **No effect system**: External effects not executable, awaiting item 010

**What's Missing:**
- No example modules demonstrating workflow patterns with narrative explanations
- No test module validating example trace structures
- No documentation showing how to use the executor for real workflows

## Desired End State

Four example modules in src/wf_example_*.erl, each exporting:
1. `term/0 -> wf_bc()` - Returns the workflow bytecode definition
2. `run/0 -> {ok, [#trace_event{}]}` - Executes workflow with trace collection, prints execution summary, returns events
3. `expected_trace_structure/0 -> [atom()]` - Returns list of opcode category names for validation

Test module test/wf_test_examples.erl with EUnit tests validating each example's trace matches expected structure.

Each example includes:
- Realistic scenario (vending machine, approval, cancel region, multiple instances)
- Detailed comments explaining each opcode and pattern
- Mock effects simulated via TASK_EXEC opcodes that update context
- Clear documentation of limitations (MI_SPAWN, cancellation)

### Key Discoveries:

- **wf_exec:new/1** (lines 80-101): Creates executor from bytecode with initial token at IP=0, root scope
- **wf_exec:run/3** (lines 149-166): Executes workflow with quanta limit, returns {done, ExecState}
- **wf_trace:new/1** (lines 80-94): Creates trace state with ETS sink, returns {ok, #trace_state{}}
- **wf_trace:get_events/1** (lines 129-142): Retrieves events from ETS sink via ets:tab2list/1
- **erlang:put(wf_trace_state, TraceState)**: Enables tracing in executor (wf_test_trace_helpers.erl:84)
- **PAR_FORK workaround**: Can simulate MI_SPAWN using PAR_FORK with multiple branches (wf_test_par.erl:54-64)
- **Join policy first_complete**: Implements discriminator pattern (wf_test_par.erl:66-76)

## What We're NOT Doing

- Implementing MI_SPAWN opcode handler (awaiting item 009)
- Implementing actual cancellation behavior (awaiting item 008)
- Adding effect system integration (awaiting item 010)
- Creating scheduler module (not in scope)
- Modifying executor core logic
- Adding new opcodes
- Creating visual workflow editor or DSL
- Writing production-ready workflow templates
- Adding persistence or recovery features
- Creating workflow composition API (e.g., seq/2, par/2)

## Implementation Approach

Create four example modules following the test module pattern but with narrative, educational focus. Each module will:

1. **Define bytecode as list literal** (not generated by functions)
2. **Include detailed comments** explaining each opcode and its role
3. **Use PAR_FORK to simulate MI_SPAWN** with clear documentation
4. **Document limitations** (cancellation stubbed, MI not implemented)
5. **Return trace events** from run/0 for programmatic use
6. **Print execution summary** to console for demo purposes

Testing strategy:
- Extract opcode category name from each trace event
- Compare to expected structure list
- Assert match with EUnit

All examples use full trace level to show complete execution flow, making traces more educational.

---

## Phases

### Phase 1: Create Basic Example (wf_example_basic.erl)

#### Overview

Demonstrate Sequence + XOR Choice pattern with a vending machine scenario. User inserts coin, then either selects drink (â†’ dispense) OR requests refund. This shows the most fundamental workflow patterns: sequential execution and exclusive choice.

#### Changes Required:

##### 1. Basic Example Module

**File**: `src/wf_example_basic.erl`
**Changes**: Create new module with vending machine workflow

```erlang
-module(wf_example_basic).
-export([term/0, run/0, expected_trace_structure/0]).
-include_lib("kernel/include/logger.hrl").

%% @doc Returns the vending machine workflow bytecode term
%% Pattern: seq(task(insert_coin), xor([seq(task(select_drink), task(dispense)), task(refund)]))
%% Demonstrates: SEQ_ENTER, SEQ_NEXT, XOR_CHOOSE, TASK_EXEC, DONE
term() ->
    [
        {'SEQ_ENTER', 0},          % Start sequential scope
        {'TASK_EXEC', insert_coin}, % Task: insert coin
        {'XOR_CHOOSE', [3, 7]},    % Choose: select drink (IP=3) OR refund (IP=7)
        {'SEQ_ENTER', 0},          % Start nested sequence for drink selection
        {'TASK_EXEC', select_drink},% Task: select drink
        {'SEQ_NEXT', 6},           % Jump to dispense task
        {'TASK_EXEC', dispense},    % Task: dispense drink
        {'DONE'},                  % Complete drink selection branch
        {'TASK_EXEC', refund},     % Task: refund coin
        {'DONE'}                   % Complete refund branch
    ].

%% @doc Executes the workflow and returns trace events
run() ->
    Bytecode = term(),
    {ok, TraceState} = wf_trace:new(full),
    erlang:put(wf_trace_state, TraceState),
    ExecState = wf_exec:new(Bytecode),
    {done, DoneState} = wf_exec:run(ExecState, 1000, undefined),
    Events = wf_trace:get_events(TraceState),

    %% Print execution summary
    io:format("~n=== Vending Machine Workflow ===~n"),
    io:format("Steps executed: ~p~n", [DoneState#exec_state.step_count]),
    io:format("Tokens in final state: ~p~n", [maps:size(DoneState#exec_state.tokens)]),
    io:format("Trace events: ~p~n", [length(Events)]),
    print_trace(Events),

    {ok, Events}.

%% @doc Expected sequence of opcode categories for validation
%% Note: XOR_CHOOSE nondeterministically selects branch, but executor is deterministic
%% With current stubbed scheduler, first branch (select_drink) is always chosen
expected_trace_structure() ->
    [
        seq_enter,      % Enter outer sequence
        task_exec,     % insert_coin
        xor_choose,    % Choose branch
        seq_enter,     % Enter nested sequence
        task_exec,     % select_drink
        seq_next,      % Jump to dispense
        task_exec,     % dispense
        done           % Complete workflow
    ].

%% @private Print trace events for debugging
print_trace(Events) ->
    lists:foreach(fun(E) ->
        OpCat = extract_category(E),
        io:format("  ~p~n", [OpCat])
    end, Events).

%% @private Extract opcode category from trace event
extract_category(#trace_event{opcode = {OpName, _Arg}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName)));
extract_category(#trace_event{opcode = OpName}) when is_atom(OpName) ->
    list_to_atom(string:lowercase(atom_to_list(OpName))).
```

**Rationale:**
- Bytecode uses literal list for clarity (not generated)
- SEQ_ENTER marks sequential scope boundaries
- XOR_CHOOSE with [3, 7] chooses between two branches (drink or refund)
- SEQ_NEXT jumps over the unselected branch
- Comments explain each opcode's purpose
- run/0 prints summary AND returns events for both demo and programmatic use

#### Success Criteria:

##### Automated Verification:

- [ ] Module compiles: `erlc -I src -o ebin src/wf_example_basic.erl`
- [ ] term/0 returns valid wf_bc() type
- [ ] run/0 executes without errors
- [ ] run/0 returns {ok, Events} where Events is list of #trace_event{}

##### Manual Verification:

- [ ] Compile and run from Erlang shell: `wf_example_basic:run().`
- [ ] Verify console output shows execution summary
- [ ] Verify trace events match expected structure
- [ ] Verify workflow completes (no tokens left in active state)

**Note**: Complete all automated verification, then pause for manual confirmation before proceeding to next phase.

---

### Phase 2: Create Discriminator Example (wf_example_discriminator.erl)

#### Overview

Demonstrate Discriminator pattern (parallel split + first-complete join). Three parallel approval tasks (manager, director, VP) execute concurrently; first approval cancels the rest. Shows PAR_FORK, JOIN_WAIT with first_complete policy, and automatic cancellation behavior.

#### Changes Required:

##### 1. Discriminator Example Module

**File**: `src/wf_example_discriminator.erl`
**Changes**: Create new module with approval workflow

```erlang
-module(wf_example_discriminator).
-export([term/0, run/0, expected_trace_structure/0]).
-include_lib("kernel/include/logger.hrl").

%% @doc Returns the discriminator workflow bytecode term
%% Pattern: discriminator(par([task(approve_manager), task(approve_director), task(approve_vp)]))
%% Demonstrates: PAR_FORK, JOIN_WAIT with first_complete, DONE
%% The first task to complete causes the join to fire, cancelling remaining tasks
term() ->
    [
        {'PAR_FORK', [1, 3, 5]},      % Fork into 3 parallel branches
        {'TASK_EXEC', approve_manager},% Branch 1: manager approval
        {'DONE'},                      % Complete branch 1
        {'TASK_EXEC', approve_director},% Branch 2: director approval
        {'DONE'},                      % Complete branch 2
        {'TASK_EXEC', approve_vp},     % Branch 3: VP approval
        {'DONE'},                      % Complete branch 3
        {'JOIN_WAIT', first_complete}, % Wait for FIRST completion only
        {'TASK_EXEC', notify_result},   % Notify result
        {'DONE'}                       % Complete workflow
    ].

%% @doc Executes the workflow and returns trace events
run() ->
    Bytecode = term(),
    {ok, TraceState} = wf_trace:new(full),
    erlang:put(wf_trace_state, TraceState),
    ExecState = wf_exec:new(Bytecode),
    {done, DoneState} = wf_exec:run(ExecState, 1000, undefined),
    Events = wf_trace:get_events(TraceState),

    %% Print execution summary
    io:format("~n=== Discriminator (Approval) Workflow ===~n"),
    io:format("Steps executed: ~p~n", [DoneState#exec_state.step_count]),
    TokensByStatus = group_tokens_by_status(DoneState#exec_state.tokens),
    io:format("Tokens by status: ~p~n", [TokensByStatus]),
    io:format("Trace events: ~p~n", [length(Events)]),
    print_trace(Events),

    {ok, Events}.

%% @doc Expected sequence of opcode categories
%% First branch (approve_manager) completes first, satisfying the join
expected_trace_structure() ->
    [
        par_fork,       % Fork into 3 branches
        task_exec,      % approve_manager (completes first)
        done,           % Complete branch 1
        join_wait,      % Join satisfied by first completion
        task_exec,      % notify_result
        done            % Complete workflow
    ].

%% @private Group tokens by status for summary
group_tokens_by_status(TokensMap) ->
    Tokens = maps:values(TokensMap),
    lists:foldl(fun(#token{status = Status}, Acc) ->
        maps:update_with(Status, fun(V) -> V + 1 end, 1, Acc)
    end, #{}, Tokens).

%% @private Print trace events
print_trace(Events) ->
    lists:foreach(fun(E) ->
        OpCat = extract_category(E),
        io:format("  ~p~n", [OpCat])
    end, Events).

%% @private Extract opcode category
extract_category(#trace_event{opcode = {OpName, _Arg}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName)));
extract_category(#trace_event{opcode = OpName}) when is_atom(OpName) ->
    list_to_atom(string:lowercase(atom_to_list(OpName))).
```

**Rationale:**
- PAR_FORK creates 3 parallel approval branches
- JOIN_WAIT with first_complete implements discriminator
- First branch to complete satisfies join, cancels others
- Document that cancellation of excess branches not yet implemented (item 008)
- Shows real-world approval workflow pattern

#### Success Criteria:

##### Automated Verification:

- [ ] Module compiles without errors
- [ ] term/0 returns valid bytecode
- [ ] run/0 executes and returns {ok, Events}
- [ ] Trace shows PAR_FORK, one branch completion, JOIN_WAIT satisfied

##### Manual Verification:

- [ ] Compile and run: `wf_example_discriminator:run().`
- [ ] Verify only ONE branch completes before JOIN_WAIT
- [ ] Verify final notify_result task executes
- [ ] Verify workflow completes successfully

**Note**: Complete all automated verification, then pause for manual confirmation before proceeding to next phase.

---

### Phase 3: Create Cancel Region Example (wf_example_cancel_region.erl)

#### Overview

Demonstrate Cancel Region pattern with structured cancellation. Main flow with a cancel region containing long-running subprocess. External signal triggers region cancellation mid-execution, preserving main flow. Shows CANCEL_SCOPE opcodes with enter/exit boundaries.

**IMPORTANT**: Cancellation is stubbed in wf_exec.erl:512-529 (item 008 incomplete). This example shows the bytecode structure but won't actually cancel at runtime.

#### Changes Required:

##### 1. Cancel Region Example Module

**File**: `src/wf_example_cancel_region.erl`
**Changes**: Create new module with cancel region workflow

```erlang
-module(wf_example_cancel_region).
-export([term/0, run/0, expected_trace_structure/0]).
-include_lib("kernel/include/logger.hrl").

%% @doc Returns the cancel region workflow bytecode term
%% Pattern: seq(task(start_process), cancel_region(seq(task(long_task), task(another_long_task))), task(continue_main))
%% Demonstrates: CANCEL_SCOPE with enter/exit, SEQ_ENTER, SEQ_NEXT, TASK_EXEC
%%
%% LIMITATION: Cancellation is stubbed in wf_exec.erl:512-529 (awaiting item 008)
%% This example shows the bytecode structure but won't actually cancel at runtime.
%% The workflow will execute completely, ignoring the cancel region semantics.
term() ->
    [
        {'CANCEL_SCOPE', {enter, main_flow}},     % Enter main cancellation scope
        {'TASK_EXEC', start_process},             % Start main process
        {'CANCEL_SCOPE', {enter, cancel_region}}, % Enter cancelable region
        {'SEQ_ENTER', 0},                          % Start sequential subprocess
        {'TASK_EXEC', long_task},                  % Long-running task (would be cancelled)
        {'SEQ_NEXT', 7},                           % Jump to next task
        {'TASK_EXEC', another_long_task},          % Another long task (would be cancelled)
        {'DONE'},                                  % End subprocess
        {'CANCEL_SCOPE', {exit, cancel_region}},   % Exit cancel region
        {'TASK_EXEC', continue_main_flow},         % Continue main flow (should execute after cancel)
        {'CANCEL_SCOPE', {exit, main_flow}}       % Exit main scope
    ].

%% @doc Executes the workflow and returns trace events
run() ->
    Bytecode = term(),
    {ok, TraceState} = wf_trace:new(full),
    erlang:put(wf_trace_state, TraceState),
    ExecState = wf_exec:new(Bytecode),
    {done, DoneState} = wf_exec:run(ExecState, 1000, undefined),
    Events = wf_trace:get_events(TraceState),

    %% Print execution summary
    io:format("~n=== Cancel Region Workflow ===~n"),
    io:format("Steps executed: ~p~n", [DoneState#exec_state.step_count]),
    io:format("LIMITATION: Cancellation is stubbed (wf_exec.erl:512-529)~n"),
    io:format("The workflow executes completely; actual cancellation not yet implemented.~n"),
    io:format("Trace events: ~p~n", [length(Events)]),
    print_trace(Events),

    {ok, Events}.

%% @doc Expected sequence of opcode categories
%% NOTE: Since cancellation is stubbed, the full workflow executes
expected_trace_structure() ->
    [
        cancel_scope_enter,  % Enter main scope
        task_exec,           % start_process
        cancel_scope_enter,  % Enter cancel region
        seq_enter,           % Start subprocess
        task_exec,           % long_task
        seq_next,            % Jump to next task
        task_exec,           % another_long_task
        done,                % End subprocess
        cancel_scope_exit,   % Exit cancel region
        task_exec,           % continue_main_flow
        cancel_scope_exit    % Exit main scope
    ].

%% @private Print trace events
print_trace(Events) ->
    lists:foreach(fun(E) ->
        OpCat = extract_category(E),
        io:format("  ~p~n", [OpCat])
    end, Events).

%% @private Extract opcode category
extract_category(#trace_event{opcode = {OpName, {enter, _Scope}}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName) ++ "_enter"));
extract_category(#trace_event{opcode = {OpName, {exit, _Scope}}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName) ++ "_exit"));
extract_category(#trace_event{opcode = {OpName, _Arg}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName)));
extract_category(#trace_event{opcode = OpName}) when is_atom(OpName) ->
    list_to_atom(string:lowercase(atom_to_list(OpName))).
```

**Rationale:**
- CANCEL_SCOPE marks region boundaries (enter/exit)
- Nested scopes: main_flow contains cancel_region
- Shows structured cancellation preserving main flow
- Clearly documents that cancellation is stubbed
- Extract function converts cancel_scope to cancel_scope_enter/exit for clarity

#### Success Criteria:

##### Automated Verification:

- [ ] Module compiles without errors
- [ ] term/0 returns valid bytecode
- [ ] run/0 executes and returns {ok, Events}
- [ ] Trace shows all CANCEL_SCOPE opcodes

##### Manual Verification:

- [ ] Compile and run: `wf_example_cancel_region:run().`
- [ ] Verify limitation message printed
- [ ] Verify full workflow executes (no actual cancellation)
- [ ] Verify trace shows cancel_scope_enter and cancel_scope_exit

**Note**: Complete all automated verification, then pause for manual confirmation before proceeding to next phase.

---

### Phase 4: Create Multiple Instances Example (wf_example_multiple_instances.erl)

#### Overview

Demonstrate Multiple Instances pattern with dynamic instance count and wait-n join. 5 parallel instances process items, waiting for 3 of 5 to succeed (partial completion). Shows PAR_FORK workaround for missing MI_SPAWN opcode.

**IMPORTANT**: MI_SPAWN opcode is not implemented (item 009 incomplete). This example uses PAR_FORK as a workaround, simulating MI with explicit branches.

#### Changes Required:

##### 1. Multiple Instances Example Module

**File**: `src/wf_example_multiple_instances.erl`
**Changes**: Create new module with multiple instances workflow

```erlang
-module(wf_example_multiple_instances).
-export([term/0, run/0, expected_trace_structure/0]).
-include_lib("kernel/include/logger.hrl").

%% @doc Returns the multiple instances workflow bytecode term
%% Pattern: mi({fixed, 5}, seq(task(process_item), done)), wait_n(3)
%% Demonstrates: PAR_FORK (workaround for MI_SPAWN), JOIN_WAIT with {wait_n, 3}
%%
%% LIMITATION: MI_SPAWN opcode is not implemented (item 009 incomplete)
%% This example uses PAR_FORK to simulate multiple instances with explicit branches.
%% The bytecode below manually creates 5 branches, which MI_SPAWN would generate automatically.
term() ->
    [
        %% PAR_FORK workaround: simulate 5 MI instances
        {'PAR_FORK', [1, 3, 5, 7, 9]},  % Spawn 5 parallel branches
        {'TASK_EXEC', process_item_1},   % Instance 1
        {'DONE'},                        % Complete instance 1
        {'TASK_EXEC', process_item_2},   % Instance 2
        {'DONE'},                        % Complete instance 2
        {'TASK_EXEC', process_item_3},   % Instance 3
        {'DONE'},                        % Complete instance 3
        {'TASK_EXEC', process_item_4},   % Instance 4
        {'DONE'},                        % Complete instance 4
        {'TASK_EXEC', process_item_5},   % Instance 5
        {'DONE'},                        % Complete instance 5
        {'JOIN_WAIT', {wait_n, 3}},      % Wait for 3 of 5 instances to complete
        {'TASK_EXEC', aggregate_results},% Aggregate results from completed instances
        {'DONE'}                         % Complete workflow
    ].

%% @doc Executes the workflow and returns trace events
run() ->
    Bytecode = term(),
    {ok, TraceState} = wf_trace:new(full),
    erlang:put(wf_trace_state, TraceState),
    ExecState = wf_exec:new(Bytecode),
    {done, DoneState} = wf_exec:run(ExecState, 1000, undefined),
    Events = wf_trace:get_events(TraceState),

    %% Print execution summary
    io:format("~n=== Multiple Instances Workflow ===~n"),
    io:format("Steps executed: ~p~n", [DoneState#exec_state.step_count]),
    TokensByStatus = group_tokens_by_status(DoneState#exec_state.tokens),
    io:format("Tokens by status: ~p~n", [TokensByStatus]),
    io:format("LIMITATION: Using PAR_FORK to simulate MI_SPAWN (awaiting item 009)~n"),
    io:format("Trace events: ~p~n", [length(Events)]),
    print_trace(Events),

    {ok, Events}.

%% @doc Expected sequence of opcode categories
%% First 3 instances complete, satisfying the {wait_n, 3} join
expected_trace_structure() ->
    [
        par_fork,             % Fork into 5 instances
        task_exec,            % process_item_1
        done,                 % Complete instance 1
        task_exec,            % process_item_2
        done,                 % Complete instance 2
        task_exec,            % process_item_3
        done,                 % Complete instance 3 (satisfies join)
        join_wait,            % Join satisfied (3 of 5)
        task_exec,            % aggregate_results
        done                  % Complete workflow
    ].

%% @private Group tokens by status for summary
group_tokens_by_status(TokensMap) ->
    Tokens = maps:values(TokensMap),
    lists:foldl(fun(#token{status = Status}, Acc) ->
        maps:update_with(Status, fun(V) -> V + 1 end, 1, Acc)
    end, #{}, Tokens).

%% @private Print trace events
print_trace(Events) ->
    lists:foreach(fun(E) ->
        OpCat = extract_category(E),
        io:format("  ~p~n", [OpCat])
    end, Events).

%% @private Extract opcode category
extract_category(#trace_event{opcode = {OpName, _Arg}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName)));
extract_category(#trace_event{opcode = OpName}) when is_atom(OpName) ->
    list_to_atom(string:lowercase(atom_to_list(OpName))).
```

**Rationale:**
- PAR_FORK simulates MI_SPAWN with explicit branch definitions
- 5 parallel branches represent 5 instances
- JOIN_WAIT with {wait_n, 3} waits for partial completion
- Clearly documents limitation and workaround
- Shows real-world pattern: process multiple items, wait for threshold

#### Success Criteria:

##### Automated Verification:

- [ ] Module compiles without errors
- [ ] term/0 returns valid bytecode
- [ ] run/0 executes and returns {ok, Events}
- [ ] Trace shows 3 parallel branches completing before JOIN_WAIT

##### Manual Verification:

- [ ] Compile and run: `wf_example_multiple_instances:run().`
- [ ] Verify limitation message printed
- [ ] Verify 3 branches complete before join satisfied
- [ ] Verify aggregate_results task executes after join

**Note**: Complete all automated verification, then pause for manual confirmation before proceeding to next phase.

---

### Phase 5: Create Test Module (wf_test_examples.erl)

#### Overview

Create EUnit test module that validates each example's actual trace structure matches its expected structure. Tests extract opcode categories from trace events and compare to expected lists.

#### Changes Required:

##### 1. Test Module for Examples

**File**: `test/wf_test_examples.erl`
**Changes**: Create new test module with EUnit tests

```erlang
-module(wf_test_examples).
-include_lib("eunit/include/eunit.hrl").

%%====================================================================
%% Example Basic Tests
%%====================================================================

example_basic_trace_structure_test() ->
    {ok, Events} = wf_example_basic:run(),
    Expected = wf_example_basic:expected_trace_structure(),
    Actual = extract_categories(Events),
    ?assertEqual(Expected, Actual).

example_basic_completes_successfully_test() ->
    {ok, Events} = wf_example_basic:run(),
    [LastEvent | _] = lists:reverse(Events),
    ?assertEqual(done, extract_category(LastEvent)).

%%====================================================================
%% Example Discriminator Tests
%%====================================================================

example_discriminator_trace_structure_test() ->
    {ok, Events} = wf_example_discriminator:run(),
    Expected = wf_example_discriminator:expected_trace_structure(),
    Actual = extract_categories(Events),
    ?assertEqual(Expected, Actual).

example_discriminator_parallel_fork_test() ->
    {ok, Events} = wf_example_discriminator:run(),
    %% Verify PAR_FORK creates multiple tokens
    ForkEvents = [E || E <- Events, extract_category(E) =:= par_fork],
    ?assert(length(ForkEvents) > 0).

example_discriminator_first_complete_test() ->
    {ok, Events} = wf_example_discriminator:run(),
    %% Verify JOIN_WAIT with first_complete executes
    JoinEvents = [E || E <- Events, extract_category(E) =:= join_wait],
    ?assert(length(JoinEvents) > 0).

%%====================================================================
%% Example Cancel Region Tests
%%====================================================================

example_cancel_region_trace_structure_test() ->
    {ok, Events} = wf_example_cancel_region:run(),
    Expected = wf_example_cancel_region:expected_trace_structure(),
    Actual = extract_categories(Events),
    ?assertEqual(Expected, Actual).

example_cancel_region_has_cancel_scopes_test() ->
    {ok, Events} = wf_example_cancel_region:run(),
    %% Verify CANCEL_SCOPE opcodes present
    CancelEvents = [E || E <- Events,
        is_cancel_scope_event(extract_category(E))],
    ?assert(length(CancelEvents) >= 2).  % At least enter + exit

%%====================================================================
%% Example Multiple Instances Tests
%%====================================================================

example_multiple_instances_trace_structure_test() ->
    {ok, Events} = wf_example_multiple_instances:run(),
    Expected = wf_example_multiple_instances:expected_trace_structure(),
    Actual = extract_categories(Events),
    ?assertEqual(Expected, Actual).

example_multiple_instances_parallel_fork_test() ->
    {ok, Events} = wf_example_multiple_instances:run(),
    %% Verify PAR_FORK creates 5 branches
    ForkEvents = [E || E <- Events, extract_category(E) =:= par_fork],
    ?assert(length(ForkEvents) > 0).

example_multiple_instances_wait_n_test() ->
    {ok, Events} = wf_example_multiple_instances:run(),
    %% Verify JOIN_WAIT with wait_n executes
    JoinEvents = [E || E <- Events, extract_category(E) =:= join_wait],
    ?assert(length(JoinEvents) > 0).

%%====================================================================
%% Helper Functions
%%====================================================================

%% @doc Extract list of opcode categories from trace events
extract_categories(Events) ->
    [extract_category(E) || E <- Events].

%% @doc Extract opcode category from single trace event
extract_category(#trace_event{opcode = {OpName, {enter, _Scope}}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName) ++ "_enter"));
extract_category(#trace_event{opcode = {OpName, {exit, _Scope}}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName) ++ "_exit"));
extract_category(#trace_event{opcode = {OpName, _Arg}}) ->
    list_to_atom(string:lowercase(atom_to_list(OpName)));
extract_category(#trace_event{opcode = OpName}) when is_atom(OpName) ->
    list_to_atom(string:lowercase(atom_to_list(OpName))).

%% @doc Check if category is a cancel_scope event
is_cancel_scope_event(cancel_scope_enter) -> true;
is_cancel_scope_event(cancel_scope_exit) -> true;
is_cancel_scope_event(_) -> false.
```

**Rationale:**
- Each example has trace structure test validating expected vs actual
- Additional tests verify specific patterns (PAR_FORK, JOIN_WAIT, CANCEL_SCOPE)
- Helper functions extract opcode categories from events
- Tests use EUnit assertions
- Follows existing test module patterns (wf_test_seq, wf_test_par, etc.)

#### Success Criteria:

##### Automated Verification:

- [ ] Module compiles without errors
- [ ] All tests pass: `rebar3 eunit --module=wf_test_examples`
- [ ] Tests execute each example module
- [ ] Tests validate trace structures

##### Manual Verification:

- [ ] Run tests manually: `rebar3 eunit --module=wf_test_examples`
- [ ] Verify all tests pass green
- [ ] Verify test output shows 11 tests (4 trace structure + 7 pattern validation)

**Note**: Complete all automated verification, then pause for manual confirmation before proceeding to next phase.

---

## Testing Strategy

### Unit Tests:

- **wf_test_examples.erl**: Validate each example's trace structure matches expected
- **trace_structure_test**: For each example, compare actual opcode categories to expected list
- **pattern_validation_test**: For each example, verify specific patterns (PAR_FORK, JOIN_WAIT, CANCEL_SCOPE)
- **completion_test**: Verify each example workflow completes successfully

### Integration Tests:

- **Compile all modules**: Ensure all four example modules compile without errors
- **Run examples interactively**: Test run/0 function from Erlang shell
- **Trace collection**: Verify trace events collected correctly with full trace level
- **Cross-module integration**: Verify examples use wf_exec, wf_trace correctly

### Manual Testing Steps:

1. **Compile all modules**: `rebar3 compile`
2. **Run basic example**: `erl -pa ebin -eval "wf_example_basic:run()." -s init stop -noshell`
3. **Run discriminator example**: `erl -pa ebin -eval "wf_example_discriminator:run()." -s init stop -noshell`
4. **Run cancel region example**: `erl -pa ebin -eval "wf_example_cancel_region:run()." -s init stop -noshell`
5. **Run multiple instances example**: `erl -pa ebin -eval "wf_example_multiple_instances:run()." -s init stop -noshell`
6. **Run unit tests**: `rebar3 eunit --module=wf_test_examples`
7. **Verify all tests pass**: Check for "All 11 tests passed."

## Migration Notes

No migration required. This is new code only, with no changes to existing modules or data structures.

## References

- Research: `/Users/speed/wf-substrate/.wreckit/items/018-example-workflows/research.md`
- Core executor: `/Users/speed/wf-substrate/src/wf_exec.erl:80-101` (wf_exec:new/1)
- Tracing infrastructure: `/Users/speed/wf-substrate/src/wf_trace.erl:80-94` (wf_trace:new/1)
- Test patterns: `/Users/speed/wf-substrate/test/wf_test_seq.erl:17-24` (bytecode structure)
- Parallel patterns: `/Users/speed/wf-substrate/test/wf_test_par.erl:17-76` (PAR_FORK + JOIN_WAIT)
- XOR patterns: `/Users/speed/wf-substrate/test/wf_test_xor.erl:17-54` (XOR_CHOOSE)
- Trace helpers: `/Users/speed/wf-substrate/test/wf_test_trace_helpers.erl:63-98` (run_with_trace/3)
- Opcode types: `/Users/speed/wf-substrate/src/wf_vm.erl:9-21` (wf_bc(), opcode())
- Join policies: `/Users/speed/wf-substrate/src/wf_vm.erl:24-29` (join_policy())
