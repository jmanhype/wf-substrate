{
  "schema_version": 1,
  "id": "006-state-store-and-atomic-commit",
  "branch_name": "wreckit/006-state-store-and-atomic-commit",
  "user_stories": [
    {
      "id": "US-001",
      "title": "Define core types and records for state store",
      "acceptance_criteria": [
        "wf_state.erl module exists and compiles",
        "State record #state{} defined with fields: case_id, ctx, tokens, scopes, metadata, buffered_mutations, ets_table",
        "Mutation record #mutation{} defined with fields: id, type, timestamp",
        "Token record #token{} defined (matching wf_exec structure): token_id, ip, scope_id, value, status",
        "Scope record #scope{} defined: scope_id, parent_scope, status, tokens, entered_at",
        "Metadata record #metadata{} defined: step_count, start_time, last_commit_time",
        "Receipt record #receipt{} defined (stub for item 010): receipt_id, case_id, mutations, timestamp, state_before_hash, state_after_hash",
        "Type specs defined: -type state(), -type mutation(), -type ctx(), -type token_id(), -type scope_id(), -type case_id(), -type receipt()",
        "All types exported with -export_type attribute",
        "Module documentation explains atomic commit protocol and crash resilience",
        "rebar3 compile succeeds with zero warnings",
        "Dialyzer passes with no type errors"
      ],
      "priority": 1,
      "status": "done",
      "notes": "This is the foundation for all state store operations. Records and types must be defined before any functions can be implemented. Decision: Use -opaque for state() to encapsulate implementation, but export transparent types for ctx, token_id, etc."
    },
    {
      "id": "US-002",
      "title": "Implement state creation and basic accessors",
      "acceptance_criteria": [
        "new/1 function implemented with spec: -spec new(ctx()) -> {ok, state()}",
        "new/1 creates state with unique case_id (make_ref)",
        "new/1 initializes root scope with status=active",
        "new/1 initializes metadata with step_count=0 and start_time",
        "new/1 inserts state into ETS table",
        "get_ctx/1 function implemented: returns current ctx field",
        "get_tokens/1 function implemented: returns tokens map",
        "get_scope/2 function implemented: returns scope by ID or undefined",
        "State persists to ETS table on creation",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 1,
      "status": "done",
      "notes": "State creation initializes all fields to valid defaults. Root scope is always present. ETS table must be created before new/1 is called (handled by gen_server start_link/0)."
    },
    {
      "id": "US-003",
      "title": "Implement mutation buffering infrastructure",
      "acceptance_criteria": [
        "buffer_mutation/2 function implemented with spec: -spec buffer_mutation(state(), mutation()) -> state()",
        "buffer_mutation/2 creates #mutation{} record with unique ID and timestamp",
        "buffer_mutation/2 prepends mutation to buffered_mutations list (reversed order)",
        "buffer_mutation/2 logs warning if buffer exceeds 1000 mutations",
        "put_ctx/2 function implemented: buffers {set_ctx, NewCtx} mutation",
        "add_token/3 function implemented: buffers {add_token, TokenId, Token} mutation",
        "remove_token/2 function implemented: buffers {remove_token, TokenId} mutation",
        "enter_scope/2 function implemented: buffers {enter_scope, ScopeId, ParentScope} mutation",
        "exit_scope/2 function implemented: buffers {exit_scope, ScopeId} mutation",
        "All mutation functions return {ok, state()}",
        "Buffered mutations are NOT applied to state fields",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 1,
      "status": "done",
      "notes": "Mutation buffering is the core of the atomic commit protocol. Mutations are accumulated in reverse order (prepend for performance) and applied in original order (reversed) at commit time."
    },
    {
      "id": "US-004",
      "title": "Implement mutation validation logic",
      "acceptance_criteria": [
        "validate_mutations/2 function implemented: validates mutation list before applying",
        "validate_mutations/2 returns ok for valid mutation sequence",
        "validate_mutations/2 returns {error, Reasons} for invalid mutations",
        "Validation checks: set_ctx requires map type",
        "Validation checks: add_token requires unique token_id (not already in tokens map)",
        "Validation checks: remove_token requires token_id exists",
        "Validation checks: update_token requires token_id exists",
        "Validation checks: enter_scope requires unique scope_id",
        "Validation checks: exit_scope requires scope_id exists",
        "Validation checks: cancel_scope requires scope_id exists",
        "Validation checks: increment_step_count always valid",
        "Validation checks: set_metadata always valid",
        "Multiple validation errors returned as list",
        "Validation is strict (catches all errors before apply)",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 2,
      "status": "done",
      "notes": "Strict validation ensures state consistency. All mutations validated before any are applied. Validation failures cause commit to fail atomically (no partial state)."
    },
    {
      "id": "US-005",
      "title": "Implement mutation application logic",
      "acceptance_criteria": [
        "apply_mutations/2 function implemented: applies mutation list to state",
        "apply_mutations/2 applies mutations in order (reverse of buffer order)",
        "apply_single_mutation/2 implemented for all 10 mutation types",
        "set_ctx mutation updates ctx field",
        "update_ctx mutation applies function to ctx",
        "add_token mutation inserts token into tokens map",
        "remove_token mutation removes token from tokens map",
        "update_token mutation updates existing token",
        "enter_scope mutation inserts scope into scopes map",
        "exit_scope mutation removes scope from scopes map",
        "cancel_scope mutation updates scope status to cancelled",
        "increment_step_count mutation increments step_count",
        "set_metadata mutation replaces metadata record",
        "All mutations applied atomically (foldl)",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 2,
      "status": "done",
      "notes": "Mutation application is pure functional transformation. Each mutation type has dedicated handler. Mutations applied in order using lists:foldl for atomicity."
    },
    {
      "id": "US-006",
      "title": "Implement atomic commit and rollback",
      "acceptance_criteria": [
        "commit/1 function implemented with spec: -spec commit(state()) -> {ok, state(), receipt()} | {error, term()}",
        "commit/1 validates mutations using validate_mutations/2",
        "commit/1 returns {error, validation_failed, Reasons} if validation fails",
        "commit/1 applies mutations using apply_mutations/2",
        "commit/1 persists state to ETS table",
        "commit/1 produces receipt with mutations, timestamps, state hashes",
        "commit/1 clears buffered_mutations after successful commit",
        "commit/1 updates last_commit_time in metadata",
        "commit/1 returns {ok, NewState, Receipt} on success",
        "commit/1 fails atomically if exception during apply (rollback)",
        "rollback/1 function implemented: clears buffered_mutations without applying",
        "rollback/1 does not modify state fields",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 2,
      "status": "done",
      "notes": "Atomic commit is the core invariant. Validation → Apply → Persist → Receipt → Clear Buffer. If any step fails, no partial state applied. Rollback discards buffer without touching state."
    },
    {
      "id": "US-007",
      "title": "Implement ETS persistence via gen_server",
      "acceptance_criteria": [
        "gen_server behaviour implemented for wf_state",
        "start_link/0 function implemented: starts gen_server process",
        "init/1 callback creates wf_state_store ETS table",
        "ETS table is named, set type, public, with read_concurrency and write_concurrency",
        "ETS table keypos is #state.case_id",
        "ETS table owned by gen_server process (survives case runner crashes)",
        "new/1 inserts state into ETS table",
        "commit/1 updates state in ETS table",
        "restore_from_ets/1 function implemented: loads state by case_id",
        "restore_from_ets/1 returns {ok, State} or {error, not_found}",
        "State persists across process crashes",
        "gen_server terminates gracefully and deletes ETS table",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 2,
      "status": "done",
      "notes": "ETS table ownership by separate gen_server ensures crash resilience. State persisted on every commit, restorable on crash. Table deleted when gen_server terminates (application shutdown)."
    },
    {
      "id": "US-008",
      "title": "Implement snapshot and restore for debugging",
      "acceptance_criteria": [
        "snapshot/1 function implemented with spec: -spec snapshot(state()) -> binary()",
        "snapshot/1 serializes state using term_to_binary",
        "snapshot/1 excludes buffered_mutations from binary",
        "snapshot/1 excludes ets_table from binary",
        "restore/2 function implemented with spec: -spec restore(binary(), case_id()) -> {ok, state()} | {error, term()}",
        "restore/2 deserializes binary using binary_to_term",
        "restore/2 validates case_id matches snapshot",
        "restore/2 resets buffered_mutations to empty list",
        "restore/2 resets ets_table to current reference",
        "restore/2 returns {error, invalid_snapshot} for malformed binary",
        "restore/2 returns {error, case_id_mismatch} if case_id doesn't match",
        "Snapshot and restore round-trip preserves state",
        "rebar3 compile succeeds",
        "Dialyzer passes"
      ],
      "priority": 3,
      "status": "done",
      "notes": "Snapshot/restore is for debugging and replay. Non-serializable fields (pids, refs, ports) not supported. Term_to_binary sufficient for v1; custom format future work."
    },
    {
      "id": "US-009",
      "title": "Create comprehensive test suite for wf_state",
      "acceptance_criteria": [
        "test/wf_state_tests.erl module exists and compiles",
        "Tests for state creation: new/1 creates valid state",
        "Tests for basic accessors: get_ctx/1, get_tokens/1, get_scope/2 return correct values",
        "Tests for mutation buffering: buffer_mutation/2 accumulates mutations",
        "Tests for context updates: put_ctx/2 buffers set_ctx mutation",
        "Tests for token management: add_token/3, remove_token/2 buffer mutations",
        "Tests for scope management: enter_scope/2, exit_scope/2 buffer mutations",
        "Tests for validation: validate_mutations/2 catches all invalid inputs",
        "Tests for mutation application: apply_mutations/2 applies all mutations",
        "Tests for atomic commit: commit/1 validates, applies, persists, produces receipt",
        "Tests for validation failure: commit/1 returns error, state unchanged",
        "Tests for rollback: rollback/1 discards buffered mutations",
        "Tests for snapshot/restore: snapshot serializes, restore deserializes",
        "Tests for ETS persistence: state persists to ETS, restorable",
        "Tests for error handling: commit fails atomically on exception",
        "Tests for edge cases: empty state, large buffers, nested scopes",
        "rebar3 eunit passes all tests (100% success)",
        "Code coverage > 90% for wf_state.erl"
      ],
      "priority": 3,
      "status": "done",
      "notes": "Comprehensive test coverage is critical for state correctness. Tests must cover success paths, error paths, and edge cases. Use EUnit test generators for flexible test organization."
    },
    {
      "id": "US-010",
      "title": "Integration verification and documentation",
      "acceptance_criteria": [
        "rebar3 compile succeeds with zero warnings",
        "rebar3 dialyzer passes with no type errors",
        "rebar3 eunit passes all tests (100% success)",
        "Code coverage > 90% for wf_state.erl",
        "All exported functions have complete -spec declarations",
        "All exported functions have -doc comments",
        "Module documentation explains atomic commit protocol",
        "Module documentation explains crash resilience strategy",
        "Module documentation lists all mutation types",
        "Design decisions documented in module header",
        "No circular dependencies",
        "State store is independent of wf_exec (standalone module)",
        "Manual review confirms atomic commit invariant preserved",
        "Manual review confirms crash resilience via ETS",
        "Manual review confirms receipt generation on every commit",
        "Ready for integration with wf_exec (item 005 refactoring)"
      ],
      "priority": 4,
      "status": "done",
      "notes": "Final verification phase ensuring state store is production-ready. Atomic commit invariant is critical: crash mid-quantum leaves no partial state. ETS persistence enables crash recovery. Receipts enable audit and replay."
    }
  ]
}
