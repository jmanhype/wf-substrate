-module(wf_test_term).
-include_lib("eunit/include/eunit.hrl").
-include("../src/wf_exec.hrl").

%%====================================================================
%% Bytecode Structure Tests
%%====================================================================

%% Test opcode format validation
opcode_format_test() ->
    %% Valid opcodes from wf_vm:wf_bc() type
    ValidOpcodes = [
        {'TASK_EXEC', task},
        {'DONE'},
        {'SEQ_ENTER', 0},
        {'SEQ_NEXT', 5},
        {'PAR_FORK', [1, 3]},
        {'XOR_CHOOSE', [1, 3]},
        {'JOIN_WAIT', all},
        {'JOIN_WAIT', {wait_n, 2}},
        {'JOIN_WAIT', first_complete},
        {'CANCEL_SCOPE', {enter, scope}}
    ],
    lists:foreach(fun(Op) ->
        ?assert(is_tuple(Op)),
        ?assert(is_atom(element(1, Op)))
    end, ValidOpcodes).

%% Test label resolution in bytecode
label_resolution_test() ->
    %% PAR_FORK with valid targets
    Bytecode = [
        {'PAR_FORK', [1, 3]},
        {'TASK_EXEC', task_a},
        {'DONE'},
        {'TASK_EXEC', task_b},
        {'DONE'},
        {'JOIN_WAIT', all}
    ],
    %% All label targets should be within bytecode bounds
    {_, Labels} = lists:keyfind('PAR_FORK', 1, Bytecode),
    MaxIP = length(Bytecode) - 1,
    lists:foreach(fun(Label) ->
        ?assert(Label >= 0 andalso Label =< MaxIP)
    end, Labels).

%% Test label resolution for XOR
xor_label_resolution_test() ->
    Bytecode = [
        {'XOR_CHOOSE', [1, 3, 5]},
        {'TASK_EXEC', task_a},
        {'DONE'},
        {'TASK_EXEC', task_b},
        {'DONE'},
        {'TASK_EXEC', task_c},
        {'DONE'}
    ],
    {_, Labels} = lists:keyfind('XOR_CHOOSE', 1, Bytecode),
    MaxIP = length(Bytecode) - 1,
    lists:foreach(fun(Label) ->
        ?assert(Label >= 0 andalso Label =< MaxIP)
    end, Labels).

%% Test structural properties
balanced_scopes_test() ->
    %% CANCEL_SCOPE enter/exit should be balanced
    Bytecode = [
        {'CANCEL_SCOPE', {enter, scope1}},
        {'TASK_EXEC', task},
        {'CANCEL_SCOPE', {exit, scope1}}
    ],
    ExecState = wf_exec:new(Bytecode),
    ?assertEqual(1, length(ExecState#exec_state.scope_stack)).

unbalanced_scopes_test() ->
    %% Unbalanced scopes (missing exit)
    Bytecode = [
        {'CANCEL_SCOPE', {enter, scope1}},
        {'TASK_EXEC', task}
        %% Missing exit
    ],
    ExecState = wf_exec:new(Bytecode),
    ?assertEqual(1, length(ExecState#exec_state.scope_stack)).

%%====================================================================
%% Property Tests: Random Bytecode Generation
%%====================================================================

%% Property: any generated bytecode has valid opcodes
prop_random_bytecode_valid_opcodes_test() ->
    Property = fun(Bytecode) ->
        lists:foreach(fun(Op) ->
            ?assert(is_tuple(Op)),
            ?assert(is_atom(element(1, Op)))
        end, Bytecode)
    end,
    wf_prop:for_all(fun() -> wf_prop:random_term(5) end, Property, 50).

%% Property: any generated bytecode can be executed without crashing
prop_random_bytecode_executable_test() ->
    Property = fun(Bytecode) ->
        ExecState = wf_exec:new(Bytecode),
        ?assert(is_record(ExecState, exec_state))
    end,
    wf_prop:for_all(fun() -> wf_prop:random_term(3) end, Property, 50).

%% Property: execution terminates within bounded steps
prop_bounded_termination_test() ->
    Property = fun(Bytecode) ->
        ExecState0 = wf_exec:new(Bytecode),
        Result = wf_exec:run(ExecState0, 1000, undefined),
        case Result of
            {done, _} -> ok;
            {yield, _} -> ok;
            {error, _} -> ok;
            _ -> ?assert(false)
        end
    end,
    wf_prop:for_all(fun() -> wf_prop:random_term(3) end, Property, 50).

%% Property: well-formed bytecode has valid labels
prop_valid_labels_test() ->
    Property = fun(Bytecode) ->
        validate_labels(Bytecode)
    end,
    wf_prop:for_all(fun() -> wf_prop:random_term(4) end, Property, 50).

%%====================================================================
%% Helper Functions
%%====================================================================

%% @doc Validate all jump targets are within bytecode bounds
validate_labels(Bytecode) ->
    MaxIP = length(Bytecode) - 1,
    lists:foreach(fun({Op, Args}) when Op =:= 'PAR_FORK'; Op =:= 'XOR_CHOOSE' ->
        case is_list(Args) of
            true ->
                lists:foreach(fun(Label) ->
                    ?assert(Label >= 0 andalso Label =< MaxIP)
                end, Args);
            false ->
                ok
        end;
       (_) ->
        ok
    end, Bytecode).
