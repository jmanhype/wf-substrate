%%%-------------------------------------------------------------------
%%% @doc Bytecode type definitions for workflow pattern VM
%%%
%%% This module defines the bytecode format (wf_bc()) and all opcode types.
%%% Bytecode is a flat list of opcodes produced by wf_compile and
%%% consumed by wf_exec. No per-step AST dispatch occurs at runtime.
%%%
%%% == Bytecode Format ==
%%%
%%% Bytecode is a flat list of tagged tuples. Each tuple represents
%%% one instruction. Opcodes are not records to ensure:
%%%   - Immutable equality (pattern matching works)
%%%   - Lightweight representation (no record overhead)
%%%   - Easy emission in lists during compilation
%%%
%%% == Opcodes ==
%%%
%%% SEQ_ENTER: Begin sequence scope (operand reserved for future use)
%%% SEQ_NEXT: Advance to next in sequence (operand is target IP)
%%% PAR_FORK: Fork N parallel branches (operand is list of target IPs)
%%% JOIN_WAIT: Block until join condition met (operand is policy)
%%% XOR_CHOOSE: Choose exclusive branch (operand is list of target IPs)
%%% LOOP_BACK: Jump back to loop head (operand is target IP)
%%% LOOP_CHECK: Check loop condition (operand is policy)
%%% CANCEL_SCOPE: Enter/exit cancel region (operand is scope_id or {enter|exit, scope_id})
%%% MI_SPAWN: Spawn multiple instances (operand is policy)
%%% TASK_EXEC: Execute task (operand is task name)
%%% DONE: Terminate execution path (no operands)
%%%
%%% From ARCHITECTURE.md:1097-1116 and PROMPT.md:162-166
%%% @end
-module(wf_vm).

%%====================================================================
%% Types
%%====================================================================

%% Bytecode is a list of opcodes
-type wf_bc() :: [opcode()].

%% Label type for unresolved bytecode
%% Labels are refs generated by make_ref() during compilation,
%% then resolved to integer IPs in second pass
-type label() :: {label, reference()}.

%% Opcodes are specific tagged tuples for each instruction
%% During compilation, opcodes may contain label references.
%% After resolution, all labels are replaced with integer IPs.
-type opcode() ::
    {seq_enter, non_neg_integer()} |              %% Begin sequence scope (operand reserved)
    {seq_next, non_neg_integer()} |              %% Advance to next in sequence (target IP)
    {par_fork, [non_neg_integer()]} |            %% Fork N parallel branches (target IPs)
    {join_wait, join_policy()} |                  %% Block until join condition met
    {xor_choose, [non_neg_integer()]} |          %% Choose exclusive branch (target IPs)
    {loop_back, non_neg_integer()} |              %% Jump back to loop head (target IP)
    {loop_check, loop_policy()} |                 %% Check loop condition (policy operand)
    {cancel_scope, {enter | exit, term()}} |     %% Enter/exit cancel region (scope_id)
    {mi_spawn, mi_policy()} |                     %% Spawn multiple instances (policy operand)
    {task_exec, atom()} |                         %% Execute task (task name operand)
    {done}.                                        %% Terminate execution path (no operands)

%% Join policies
-type join_policy() ::
    all |
    {first_n, pos_integer()} |
    {n_of_m, pos_integer(), pos_integer()} |  %% {N, M}
    first_complete |
    sync_merge.

%% Loop policies
-type loop_policy() ::
    {count, non_neg_integer()} |
    while |
    until.

%% Multiple instance policies
-type mi_policy() ::
    {fixed, pos_integer()} |
    {dynamic, pos_integer(), pos_integer()}.  %% {min, max}

%% Export types
-export_type([
    wf_bc/0,
    opcode/0,
    join_policy/0,
    loop_policy/0,
    mi_policy/0
]).
